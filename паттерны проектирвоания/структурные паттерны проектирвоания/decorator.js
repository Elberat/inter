// Декоратор (англ. decorator) позволяет динамически менять поведение объекта в рантайме.

// Пример Секция статьи "Пример"
// Допустим, нам надо логировать каждый вызов функции update():

const user = {
    name: 'Alex',
    email: 'example@site.com',
};

function update(name, email) {
    user.name = name;
    user.email = email;
}
// Мы можем добавить логирование прямо в саму функцию:

function update(name, email) {
    console.log(`Logging... ${name}, ${email}`);
    user.name = name;
    user.email = email;
}

// Но это не лучшее решение, потому что если мы захотим добавить логирование куда-то ещё, нам придётся дублировать ту же функциональность. Лучше использовать декоратор, который будет «оборачивать» функцию и «обогащать» её поведение логированием:

function loggingDecorator(fn) {
    return function wrapped(...args) {
        console.log(`Logging... ${args.join(',')}`);
        return fn(...args);
    };
}

// Мы создаём функцию высшего порядка — то есть функцию, которая принимает другую функцию как аргумент и возвращает функцию как результат.

// Аргумент fn — это функция, которую мы хотим «обогатить» дополнительной функциональностью. Сама эта дополнительная функциональность находится внутри возвращаемой функции wrapped.

// Во wrapped мы сперва логируем переданные аргументы, потом вызываем оригинальную функцию fn и возвращаем её результат.

// Использовать теперь мы это можем так:

const updateWithLogging = loggingDecorator(update);
updateWithLogging('Alice', 'test@test.com');

// Logging... Alice, test@test.com

console.log(user);
// {name: 'Alice', email: 'test@test.com'}

// Когда использовать Секция статьи "Когда использовать"
// Используйте декораторы для выделения повторяющейся и расширяющей поведение объектов логики. Особенно это полезно для выделения кода, который можно использовать в разных модулях и задачах.
